/******/ (() => { // webpackBootstrap
var __webpack_exports__ = {};
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
// fibonacci implemented imperative
// using an array with the numbers 0, 1
// while loop that checks if the numbers length
// is smaller than the numbers
// if it is push the numbers array length - 2 plus the sum of array length -1
// since fibonacci returns the is the sum of the previous two numbers
// it will return in the array the elements

function imperativeFibonacci(num) {
  const numbers = [0, 1];
  while (numbers.length < num) {
    numbers.push(numbers[numbers.length - 2] + numbers[numbers.length - 1]);
  }
  return numbers;
}
console.log(imperativeFibonacci(8));

// fibonacci implemented recursive
// using as parameters that will point to the
// first and second element of the array
// with condition that check if the secondNum length is bigger and
// equal to the firstNum return the secondNum
// else return the firstNum and the secondNum using spread operator
// that will copy the elements of the secondNum which will calculate
// the sum of the secondNum length - 2 and the secondNum length - 1
// which will return the previous numbers of fibonacci sequence

const recursiveFibonacci = function (firstNum) {
  let secondNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1];
  if (secondNum.length >= firstNum) return secondNum;
  return recursiveFibonacci(firstNum, [...secondNum, secondNum[secondNum.length - 2] + secondNum[secondNum.length - 1]]);
};
console.log(recursiveFibonacci(8));
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVNBLG1CQUFtQkEsQ0FBQ0MsR0FBRyxFQUFFO0VBQ2hDLE1BQU1DLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFFdEIsT0FBT0EsT0FBTyxDQUFDQyxNQUFNLEdBQUdGLEdBQUcsRUFBRTtJQUMzQkMsT0FBTyxDQUFDRSxJQUFJLENBQUNGLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUdELE9BQU8sQ0FBQ0EsT0FBTyxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7RUFDekU7RUFDQSxPQUFPRCxPQUFPO0FBQ2hCO0FBRUFHLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDTixtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1PLGtCQUFrQixHQUFHLFNBQUFBLENBQUNDLFFBQVEsRUFBeUI7RUFBQSxJQUF2QkMsU0FBUyxHQUFBQyxTQUFBLENBQUFQLE1BQUEsUUFBQU8sU0FBQSxRQUFBQyxTQUFBLEdBQUFELFNBQUEsTUFBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDdEQsSUFBSUQsU0FBUyxDQUFDTixNQUFNLElBQUlLLFFBQVEsRUFBRSxPQUFPQyxTQUFTO0VBQ2xELE9BQU9GLGtCQUFrQixDQUFDQyxRQUFRLEVBQUUsQ0FDbEMsR0FBR0MsU0FBUyxFQUNaQSxTQUFTLENBQUNBLFNBQVMsQ0FBQ04sTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHTSxTQUFTLENBQUNBLFNBQVMsQ0FBQ04sTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUNsRSxDQUFDO0FBQ0osQ0FBQztBQUVERSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0Msa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLXJlcG9zaXRvcnkvLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZmlib25hY2NpIGltcGxlbWVudGVkIGltcGVyYXRpdmVcclxuLy8gdXNpbmcgYW4gYXJyYXkgd2l0aCB0aGUgbnVtYmVycyAwLCAxXHJcbi8vIHdoaWxlIGxvb3AgdGhhdCBjaGVja3MgaWYgdGhlIG51bWJlcnMgbGVuZ3RoXHJcbi8vIGlzIHNtYWxsZXIgdGhhbiB0aGUgbnVtYmVyc1xyXG4vLyBpZiBpdCBpcyBwdXNoIHRoZSBudW1iZXJzIGFycmF5IGxlbmd0aCAtIDIgcGx1cyB0aGUgc3VtIG9mIGFycmF5IGxlbmd0aCAtMVxyXG4vLyBzaW5jZSBmaWJvbmFjY2kgcmV0dXJucyB0aGUgaXMgdGhlIHN1bSBvZiB0aGUgcHJldmlvdXMgdHdvIG51bWJlcnNcclxuLy8gaXQgd2lsbCByZXR1cm4gaW4gdGhlIGFycmF5IHRoZSBlbGVtZW50c1xyXG5cclxuZnVuY3Rpb24gaW1wZXJhdGl2ZUZpYm9uYWNjaShudW0pIHtcclxuICBjb25zdCBudW1iZXJzID0gWzAsIDFdO1xyXG5cclxuICB3aGlsZSAobnVtYmVycy5sZW5ndGggPCBudW0pIHtcclxuICAgIG51bWJlcnMucHVzaChudW1iZXJzW251bWJlcnMubGVuZ3RoIC0gMl0gKyBudW1iZXJzW251bWJlcnMubGVuZ3RoIC0gMV0pO1xyXG4gIH1cclxuICByZXR1cm4gbnVtYmVycztcclxufVxyXG5cclxuY29uc29sZS5sb2coaW1wZXJhdGl2ZUZpYm9uYWNjaSg4KSk7XHJcblxyXG4vLyBmaWJvbmFjY2kgaW1wbGVtZW50ZWQgcmVjdXJzaXZlXHJcbi8vIHVzaW5nIGFzIHBhcmFtZXRlcnMgdGhhdCB3aWxsIHBvaW50IHRvIHRoZVxyXG4vLyBmaXJzdCBhbmQgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIGFycmF5XHJcbi8vIHdpdGggY29uZGl0aW9uIHRoYXQgY2hlY2sgaWYgdGhlIHNlY29uZE51bSBsZW5ndGggaXMgYmlnZ2VyIGFuZFxyXG4vLyBlcXVhbCB0byB0aGUgZmlyc3ROdW0gcmV0dXJuIHRoZSBzZWNvbmROdW1cclxuLy8gZWxzZSByZXR1cm4gdGhlIGZpcnN0TnVtIGFuZCB0aGUgc2Vjb25kTnVtIHVzaW5nIHNwcmVhZCBvcGVyYXRvclxyXG4vLyB0aGF0IHdpbGwgY29weSB0aGUgZWxlbWVudHMgb2YgdGhlIHNlY29uZE51bSB3aGljaCB3aWxsIGNhbGN1bGF0ZVxyXG4vLyB0aGUgc3VtIG9mIHRoZSBzZWNvbmROdW0gbGVuZ3RoIC0gMiBhbmQgdGhlIHNlY29uZE51bSBsZW5ndGggLSAxXHJcbi8vIHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBwcmV2aW91cyBudW1iZXJzIG9mIGZpYm9uYWNjaSBzZXF1ZW5jZVxyXG5cclxuY29uc3QgcmVjdXJzaXZlRmlib25hY2NpID0gKGZpcnN0TnVtLCBzZWNvbmROdW0gPSBbMCwgMV0pID0+IHtcclxuICBpZiAoc2Vjb25kTnVtLmxlbmd0aCA+PSBmaXJzdE51bSkgcmV0dXJuIHNlY29uZE51bTtcclxuICByZXR1cm4gcmVjdXJzaXZlRmlib25hY2NpKGZpcnN0TnVtLCBbXHJcbiAgICAuLi5zZWNvbmROdW0sXHJcbiAgICBzZWNvbmROdW1bc2Vjb25kTnVtLmxlbmd0aCAtIDJdICsgc2Vjb25kTnVtW3NlY29uZE51bS5sZW5ndGggLSAxXSxcclxuICBdKTtcclxufTtcclxuXHJcbmNvbnNvbGUubG9nKHJlY3Vyc2l2ZUZpYm9uYWNjaSg4KSk7XHJcbiJdLCJuYW1lcyI6WyJpbXBlcmF0aXZlRmlib25hY2NpIiwibnVtIiwibnVtYmVycyIsImxlbmd0aCIsInB1c2giLCJjb25zb2xlIiwibG9nIiwicmVjdXJzaXZlRmlib25hY2NpIiwiZmlyc3ROdW0iLCJzZWNvbmROdW0iLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9